いろいろなメモ：


sudoku2:

あちこちに現れる if (BoardSize == 9) の条件分岐は、BoardSizeが定数なので、コンパイル時に
不要なほうは消え去り、条件分岐命令も生成されません。条件コンパイルの代わりになっています。

sudoku2の最適化のテーマは「常識的な最適化」です。


sudoku3:

sudoku3の最適化のテーマは「C++の範囲でやれることは全部やる」です。


sudoku4:

sudoku4の最適化のテーマは「無制限」です。とにかく速くするためにならなんでもしよう、と。

まず、このプログラムが一部の環境ではmakeできないという報告がありました。問題になっているのは、
count9as.nasのアセンブルです。こちらでは再現していないのでよくわからないのですが、とにかく
そういう場合もあるので、その場合はとりあえずあきらめてください。すみません。

アセンブル結果はcount9as.objのとおりなので、これを使えばアセンブルが出来なくても問題ないと
思います。またここで使っているnaskというアセンブラは、NASMの記法にかなり近いので、最初の
数行をコメントアウトすれば、おそらくNASMでもアセンブルできるのではないかと思われます。

それなら最初から世間でよく知られたNASMを使えばいいじゃないかという話になるわけですが、
私としては自分の使い慣れたものを使っているだけです。私としては高速に動作するsudoku4.exeを
提供することが目的で、これが普通のWindowsで問題なく動けばそれでよく、その開発ツールまでが
みなさんの環境で動作するかまでは気を配っていません。ソースの公開も隠す必要がないから公開
しているだけで、みなさんの環境ではビルドできずに役立たずかもしれません。

_count9AsmはC++からの入り口で、メインの関数ではありません。subsubが本体で、これがC++で
いうところのcount()とcheckCell()に相当しています。

subsubは次のような初期値を持って呼び出すことになっています。この初期値の設定が_count9Asm
の仕事です。

    ESI = &board[0]
    EBX = i (探し始めの位置, 0〜80)
    EDI = n
    [EBP+0] = this
    [EBP+4] = &n

    EAX,ECX,EDXの値は破壊されます。EBX,ESP,EBP,ESIの値は保存されます。EDIは結果が入ります。

count()が再帰関数だったので、アセンブラ化に伴いそれをJMPなどで最適化していると思われるかも
しれませんが、実はそんなことはしていません。subsubへ分岐する命令はすべてCALL命令で、つまり
末尾再帰のループ化などはしていないのです（というか末尾再帰ではないのできなかった）。

あちこちにfinへの分岐命令がありますが、これはRET命令に分岐しているだけです。RET命令は
関数内に一つだけにしておいたほうがどうやら高速のようだったので、そのようにしました。

できるだけasmの処理を再現するように、処理手順をC++風に書いてみます。

int i, n, *board, EAX; /* レジスタを外部変数として表現 */

void subsub(void)
{
	if (i >= BoardSize * BoardSize) { /* 空きがすべて埋まった！ */
        if (n >= 0) {
            nの値を[EBP+4]を使って書き戻す
            _storeResultAndTestLimit(this);
            n++;
        }
        return;
    }
    if (board[i] != 0) { i++; subsub(); i--; } /* 最終的にiの値を元に戻す必要があるので、再帰化した */
    switch (i) { （中略） } /* JMP  DWORD [table+EBX*4] */
caseend:
    EAXに結果を集約
    EAX ^= 0x1ff;
    if (EAX == 0) return;
    i++;
loop0:
    do {
        EAX & (-EAX) を計算 -> その値を board[i - 1] に書き込む
        /* x & (-x) を計算すると、xの中の高速なビット検索ができる */
        /* 参考: http://www.nminoru.jp/~nminoru/programming/bitcount.html#leading-0bits */
        /* sudoku3.cppでもこれを使いたかったが、これをやったらかえって遅くなったのでやめた */
        subsub();
        EAX ^= board[i - 1]
    } while (EAX != 0);
    board[i - 1] = 0;
    i--;
fin:
    return;
}

なお、case80だけは処理が少し違っています。というのは、case80の場合、選択肢は0個か1個の
場合しかなく、1個の場合はその数字で盤を埋めることで解が一つ求まると確信できるからです。
つまり EAX & (-EAX) みたいな計算をする必要がないわけです。その処理を省略することで、
高速化を狙っています。

